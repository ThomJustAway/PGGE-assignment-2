// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculatingFlocking

struct Boid
{
    uint id;
    float3 position;
    float3 targetDirection;
    float speed;
    float targetSpeed;
};

bool useCohesionRule;
bool useAlignmentRule;
bool useSeparationRule;
bool useRandomRule;
bool canBounce;

float WEIGHT_COHESION;
float WEIGHT_SEPERATION;
float WEIGHT_ALIGNMENT;
float WEIGHT_RANDOM;

float maxSpeed;
float visibility;
float separationDistance;

float maxBoundX;
float maxBoundY;
float minBoundX;
float minBoundY;
float padding;

uint sizeOfFlock;

RWStructuredBuffer<Boid> otherBoids;
RWStructuredBuffer<Boid> currentBatch;

float random(float2 seed, float minValue, float maxValue)
{
    return lerp(minValue, maxValue, frac(sin(dot(seed, float2(12.9898, 78.233))) * 43758.5453));
}

Boid DoRandomFlockBehaviour(Boid currentBoid)
{
    float2 randomSeed = float2(currentBoid.position.x , currentBoid.targetDirection.x);
    float rand = random(randomSeed ,0.0f, 1.0f);

    currentBoid.targetDirection = normalize(currentBoid.targetDirection);
    float angle = atan2(currentBoid.targetDirection.y, currentBoid.targetDirection.x);

    if (rand > 0.5f)
    {
        angle += radians(45.0f);
    }
    else
    {
        angle -= radians(45.0f);
    }

    float3 dir = float3(0, 0, 0);
    dir.x = cos(angle);
    dir.y = sin(angle);

    currentBoid.targetDirection += dir * WEIGHT_RANDOM;
    currentBoid.targetDirection = normalize(currentBoid.targetDirection);
    //Debug.Log(autonomousList[i].TargetDirection);

    float speed = random( randomSeed, 1.0f, maxSpeed);
    currentBoid.targetSpeed += speed * WEIGHT_SEPERATION;
    currentBoid.targetSpeed /= 2.0f;

    //average the speed for the boid
    return currentBoid;
}

Boid BounceBoid(Boid currentBoid)
{
    float3 boidPosition = currentBoid.position;
    float3 targetDirection = currentBoid.targetDirection;
    if(boidPosition.x > maxBoundX - padding)
    {
        targetDirection.x = -1.0f;
    }
    else if(boidPosition.x < minBoundX + padding)
    {
        targetDirection.x = 1.0f;
    }

    if(boidPosition.y > maxBoundY - padding)
    {
        targetDirection.y = -1.0f;
    }
    else if(boidPosition.x < minBoundY + padding)
    {
        targetDirection.y = 1.0f;
    }

    currentBoid.targetDirection = targetDirection;

    return currentBoid;
}

Boid TeleportBoid(Boid currentBoid)
{
    float3 boidPosition = currentBoid.position;
    float offset = 1.0f;
    if(boidPosition.x > maxBoundX)
    {
        boidPosition.x = minBoundY + offset;
    }
    else if(boidPosition.x < minBoundX)
    {
        boidPosition.x = maxBoundY - offset;
    }

    if(boidPosition.y > maxBoundY)
    {
        boidPosition.y = minBoundY + offset;
    }
    else if(boidPosition.x < minBoundY)
    {
        boidPosition.y = maxBoundX - offset;
    }
    currentBoid.position = boidPosition;
    return currentBoid;
}

Boid DoBounding(Boid currentBoid)
{
    if(canBounce)
    { //then make the boids bounce
        return BounceBoid(currentBoid);
    }
    else
    {
        return TeleportBoid(currentBoid);
    }
}

void DoFlockingCalculation(uint id){

    Boid curr = currentBatch[id];
    float3 flockDir = float3(0, 0, 0);
    float3 separationDir = float3(0, 0, 0);

    float speed = 0.0f;
    float separationSpeed = 0.0f;

    uint count = 0;
    float3 steerPos = float3(0, 0, 0);

    //over here, it will calculate the flocking behaviour of the boids
    for (uint j = 0; j < sizeOfFlock; ++j)
    {
        if (curr.id == j) continue; //if same index then just move on

        Boid other = otherBoids[j];
        float3 directionFromCurrToOther = curr.position - other.position;
        float dist = length(directionFromCurrToOther);

        if (dist < visibility)
        {
            speed += other.speed;
            flockDir += other.targetDirection;
            steerPos += other.position;
            count++;
        }

        if (dist < separationDistance)
        {
            float3 targetDirection = normalize(directionFromCurrToOther);
            separationDir += targetDirection;
            separationSpeed += dist * WEIGHT_SEPERATION;
        }
    }

    if (count > 0)
    {
        speed = speed / count;
        flockDir = flockDir / count;

        flockDir = normalize(flockDir);

        steerPos = steerPos / count;
    }
    else
    {
        //if none set this values so that it become more unpredictable
        //generate two random numbers

        //Calculate random seed for the boids so that it wont move around
        float3 randomSeed = float3(random(curr.position.x , minBoundX , maxBoundX),
            random(curr.position.y, minBoundY , maxBoundY) , 0);

        steerPos = randomSeed;
    }

    float3 flockDirection = float3(0,0,0);
    float3 separationDirection = float3(0,0,0);
    float3 alignmentDirection = float3(0,0,0);

    if(useCohesionRule)
    {
        //The reason why it is rotating around the center is because it 
        //steerPos is 0, So it will always try to center itself to the middle;
        flockDirection = (steerPos - curr.position) * WEIGHT_COHESION;
    }
    if(useAlignmentRule)
    {
        alignmentDirection = flockDir * speed * WEIGHT_ALIGNMENT;
    }
    if(useSeparationRule)
    {
        separationDirection = separationDir * separationSpeed * WEIGHT_SEPERATION;
    }

    curr.targetDirection = alignmentDirection + separationDirection + flockDirection;

    if(useRandomRule)
    {
        curr = DoRandomFlockBehaviour(curr);
    }
    
    curr = DoBounding(curr);

    currentBatch[id] = curr;
}


[numthreads(1000, 1, 1)]
void CalculatingFlocking(uint3 id : SV_DispatchThreadID)
{
    DoFlockingCalculation(id.x);
}