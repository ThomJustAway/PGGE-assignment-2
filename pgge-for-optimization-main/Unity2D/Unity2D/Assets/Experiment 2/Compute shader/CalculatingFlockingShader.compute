// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct MovementObject 
{
    uint id;
    float3 targetDirection;
    float speed;
    float targetSpeed;
    float3 position;
};

struct BoidsObstacle
{
    public float3 position; //the position of the obstacle 
    public float AvoidanceRadius;
    public float AvoidanceRadiusMultFactor;
};

bool useCohesionRule;
bool useAlignmentRule;
bool useSeparationRule;
bool useRandomRule;
bool canBounce;

float WEIGHT_COHESION;
float WEIGHT_SEPERATION;
float WEIGHT_ALIGNMENT;
float WEIGHT_RANDOM;

float maxSpeed;
float visibility;
float separationDistance;

float maxBoundX;
float maxBoundY;
float minBoundX;
float minBoundY;
float padding;

float rotationSpeed;
float deltaTime;

uint sizeOfObject;
uint sizeOfFlock;
uint sizeOfPredatorBoids;

RWStructuredBuffer<Boid> otherBoids;
RWStructuredBuffer<Boid> currentBatch;
RWStructuredBuffer<Boid> predatorBoitds;

float random(float2 seed, float minValue, float maxValue)
{
    return lerp(minValue, maxValue, frac(sin(dot(seed, float2(12.9898, 78.233))) * 43758.5453));
}

//work on this now
private MovementObject StartCalculatingFlockingRules(int i)
{
    float3 alignmentDir = new float3(0f, 0f, 0f);;
    float3 separationDir = new float3(0f, 0f, 0f);;

    float speed = 0.0f;
    float separationSpeed = 0.0f;

    int count = 0;

    float3 steerPos = new float3(0f, 0f, 0f);

    MovementObject curr = currentBatch[i];

    for (int j = 0; j < sizeOfFlock; ++j)
    {
        //in this for loop, it will go through all the 
        //boid in the game and see if there is any boids
        //that is close to the selected boids

        MovementObject other = otherBoids[j];

        if (curr.id == other.id) continue; //if not the same then move on

        float3 direction = curr.position - other.position;
        float dist = Magnitude(direction);

        if (dist < visibility)
        { //if it is around the current boid visible range (circle)
            speed += other.speed;
            alignmentDir += other.targetDirection;
            steerPos += other.position;
            count++; //use this count to find the average 
        }

        if (dist < rules.separationDistance)
        {//if the distance is lesser than the acceptable range

            //usually this if statement is true so you
            //can remove this all together

            float3 targetDirection = Normalise(direction);
            //get direction vector from other to current

            separationDir += targetDirection;
            separationSpeed += dist * WEIGHT_SEPARATION;
            //how much needs to be seperated base on the distance
            //this formula can be tweak where the shorter the distance
            //the more speed required to seperate the boids
        }
    }

    if (count > 0)
    {
        speed = speed / count;
        alignmentDir = alignmentDir / count;
        //getting the average speed and direction the flock needs to go

        alignmentDir = Normalise(alignmentDir);

        steerPos = steerPos / count;
        //finding the average position that the flock is going
    }
    else
    { //if it is equal to 0 then have some changes to the values because
        //the boids can act abit weird
        float randx = random.NextFloat(-1f,1f);
        float randy = random.NextFloat(-1f, 1f);

        separationDir = new float3(randx, randy, 0);

        float randomLerpValue = random.NextFloat(0, 1f);
        randx = Mathf.Lerp(boxBound.min.x, boxBound.max.x, randomLerpValue);
        randy = Mathf.Lerp(boxBound.min.y, boxBound.max.y, randomLerpValue);
        steerPos = new float3(randx, randy, 0);
    }

    float3 flockDirection = (steerPos - curr.position) *
        (rules.useCohesionRule ? rules.WEIGHT_COHESION : 0.0f);

    /*
    get the direction of the flock intended outcome
    if the cohesion is needed, then multiply it with
    the weight, else just ignore it
    */

    float3 separationDirection = separationDir * separationSpeed *
        (rules.useSeparationRule ? rules.WEIGHT_SEPARATION : 0.0f);
    /*
        Get the seperation direction need to seperate from the boid nearby
        This direction would be ignored if there is no seperation rule is not stated
        */

    float3 alignmentDirection = alignmentDir * speed *
        (rules.useAlignmentRule ? rules.WEIGHT_ALIGNMENT : 0.0f);
    /*
        Where the boid intended wants to go. 
        */

    curr.targetDirection = alignmentDirection +
        separationDirection +
        flockDirection;
    return curr;
}
//for random movement
private MovementObject DoRandomMovement(MovementObject boid)
{
    if (!rules.useRandomRule) return boid;

    //autonomousList[i].TargetDirection.Normalize();
    boid.targetDirection = Normalise(boid.targetDirection);
    //float rand = Mathf.Lerp(-1f, 1f, boid.targetDirection.x);
    float rand = random.NextFloat(-1f, 1f);
    float angle = Mathf.Atan2(boid.targetDirection.y, boid.targetDirection.x);

    if (rand > 0.5f)
    {
        angle += Mathf.Deg2Rad * 45.0f;
    }
    else
    {
        angle -= Mathf.Deg2Rad * 45.0f;
    }

    float3 dir = Vector3.zero;
    dir.x = Mathf.Cos(angle);
    dir.y = Mathf.Sin(angle);

    float speed = Mathf.Lerp(1.0f, rules.maxSpeed , boid.targetDirection.y);

    boid.targetSpeed += speed * rules.WEIGHT_SEPARATION;
    boid.targetSpeed /= 2.0f;

    boid.targetDirection += dir * rules.WEIGHT_RANDOM;

    boid.targetDirection = Normalise(boid.targetDirection);

    return boid;


    //average the speed for the boid
}
//for avoiding obstacles

private MovementObject DoAvoidObstacleBehaviour(MovementObject boid)
{
    if (!rules.useAvoidObstaclesRule) return boid;

    for (int j = 0; j < obstacles.Length; ++j)
    {
        var currentObstacle = obstacles[j];

        float dist = Magnitude(boid.position - currentObstacle.position);

        if (dist < currentObstacle.AvoidanceRadius)
        {
            float3 targetDirection = Normalise(boid.position - currentObstacle.position);

            boid.targetDirection += targetDirection * rules.WEIGHT_AVOID_OBSTACLES;
            boid.targetDirection = Normalise(boid.targetDirection);
        }
    }
    return boid;
}
//for handling boundries

private MovementObject DoAvoidPredatorBoidsBehaviour(MovementObject boid)
{
    //ignore this rules if the boid dont have to flee predator or if the boid is a predator
    if(!rules.useFleeOnSightEnemyRule || rules.isPredator) return boid;
            
    //do the calculation
    foreach(var predator in predatorBoids)
    {
        var targetDirection = predator.position - boid.position;
        var distanceFromEnemy = Magnitude(targetDirection); 

        if (distanceFromEnemy < rules.enemySeparationDistance)
        { //within range of the visible enemy
            targetDirection = Normalise(targetDirection);

            boid.targetDirection += targetDirection;
            boid.targetDirection = Normalise(boid.targetDirection);

            boid.targetSpeed += distanceFromEnemy * rules.WEIGHT_FLEE_ENEMY_ON_SIGHT;
            boid.targetSpeed /= 2.0f;
        }
    }
    return boid;
}

private MovementObject HandleBoundries(MovementObject boid)
{
    if (canBounce)
    {
        return BounceBoid(boid);
    }
    else
    {
        return TeleportBoid(boid);
    }
}

//complete refactoring
private MovementObject TeleportBoid(MovementObject boid)
{
    //reduce extern calls
    float3 pos = boid.position;

    if (pos.x > maxBoundX)// boxBound.max.x
    {
        //teleport boid to the left side of the map
        pos.x = minBoundX;
    }
    else if (pos.x < minBoundX)
    {
        //teleport boid to the right side of the map
        pos.x = maxBoundX;
    }

    if (pos.y > maxBoundY)
    {
        //teleport boid to the bottom of the map
        pos.y = minBoundY;
    }
    else if (pos.y < minBoundY)
    {
        //teleport boid to the top of the map
        pos.y = maxBoundY;
    }

    boid.position = pos;
    return boid;
}

//complete refactoring
private MovementObject BounceBoid(MovementObject curBoid)
{
    float3 pos = curBoid.position;

    curBoid.targetDirection = Normalise(curBoid.targetDirection);

    //for horizontal bounds
    if (pos.x + 5.0f > maxBoundX)
    {
        //if near the right bound box, force it to go left
        curBoid.targetDirection.x = -1.0f;
    }
    else if (pos.x - 5.0f < minBoundX)
    {
        //if near the left bound box, force it to go right
        curBoid.targetDirection.x = 1.0f;
    }
    //for vectical bounds
    if (pos.y + 5.0f > maxBoundY)
    {
        //if near the top bound box, force it to go down
        curBoid.targetDirection.y = -1.0f;
    }
    else if (pos.y - 5.0f < minBoundY)
    {
        //if near the bottom bound box, force it to go up
        curBoid.targetDirection.y = 1.0f;
    }

    return curBoid;
}

[numthreads(1000, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	MovementObject curr = StartCalculatingFlockingRules(id.x);
    curr = DoRandomMovement(curr); //apply random movement to the boid
    curr = DoAvoidObstacleBehaviour(curr); //apply avoid obstalce Behaviour to the boid
    curr = DoAvoidPredatorBoidsBehaviour(curr); //apply the predator for the boids
    curr = HandleBoundries(curr);//apply boundries to the boids
    //add this together to form the final direction needed for the boid.
    //place it into the output index so that it can be sed for the moving movementObject.
    currentBatch[index] = curr;
}
